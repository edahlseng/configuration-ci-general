version: 2.1

description: General purpose continuous integration configuration

orbs:
  circleci-cli: circleci/circleci-cli@0.1.8
  orbs: circleci/orb-tools@10.0.0

executors:
  node:
    docker:
      - image: circleci/node:10.22-buster
        user: circleci
  buildpack-deps:
    docker:
      - image: circleci/buildpack-deps:buster
        user: circleci
  terraform:
    parameters:
      tag:
        type: string
    docker:
      - image: edahlseng/circleci-terraform:<< parameters.tag >>-stretch
        user: circleci
  tfenv:
    docker:
      - image: edahlseng/circleci-tfenv:buster
        user: circleci

commands:
  put-all:
    description: Save all files to the workspace
    steps:
      - persist_to_workspace:
          root: . # relative to working_directory
          paths: # relative to root
            - .
  put-directory: # Deprecated (use put-path, instead)
    description: Save all files to the workspaces
    parameters:
      path:
        type: string
    steps:
      - persist_to_workspace:
          root: . # relative to working_directory
          paths: # relative to root
            - << parameters.path >>
  put-path:
    description: Save path to the workspace
    parameters:
      relative-to:
        type: string
        default: . # relative to working_directory
      path:
        type: string
    steps:
      - persist_to_workspace:
          root: << parameters.relative-to >>
          paths: # relative to root
            - << parameters.path >>
  put-test-results:
    description: Save test results
    parameters:
      path:
        type: string
    steps:
      - store_test_results:
          path: << parameters.path >>
      - store_artifacts:
          path: << parameters.path >>
  get-workspace:
    description: Load all files from workspace
    steps:
      - attach_workspace:
          at: . # relative from working_directory
  halt-if-not-release-commit:
    description: Check commit message for chore(release), halting job if false
    steps:
      - run:
          name: Ensuring commit is a release commit
          command: |
            if [[ ! $(git log --format=%b -n 1 ${CIRCLE_SHA1}) =~ "New Release:" ]]; then
              echo "Not a release commit, halting"
              circleci-agent step halt
            fi
  halt-if-release-commit:
    description: Check commit message for chore(release), halting job if true
    steps:
      - run:
          name: Ensuring commit is not a release commit
          command: |
            if [[ $(git log --format=%b -n 1 ${CIRCLE_SHA1}) =~ "New Release:" ]]; then
              echo "Release commit, halting"
              circleci-agent step halt
            fi
  add-github-to-known-hosts:
    description: Add GitHub RSA key to known_hosts file, to support SSH with GitHub
    steps:
      - run:
          name: Adding GitHub to known_hosts file
          command: |
            mkdir -p ~/.ssh

            echo 'github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==
            ' >> ~/.ssh/known_hosts
  setup-git-user:
    description: Configures Git so that actions are performed on behalf of the specified user
    parameters:
      git-ssh-fingerprint:
        type: string
      git-user-email:
        type: string
      git-user-name:
        type: string
    steps:
      - add_ssh_keys:
          fingerprints:
            - << parameters.git-ssh-fingerprint >>
      - add-github-to-known-hosts
      - run:
          name: Configuring Git user
          command: |
            git config --global user.email "<< parameters.git-user-email >>"
            git config --global user.name "<< parameters.git-user-name >>"
  tag:
    description: Tag current release commit and push the new tag
    steps:
      - run:
          name: Creating Git tag
          command: |
            versionTag=$(git log --format=%b -n 1 ${CIRCLE_SHA1} | sed -r 's/New Release: //')

            echo "Tagging commit"
            git tag "${versionTag}"
      - run:
          name: Pushing tag to Git remote
          command: git push --tags
      - put-directory:
          path: .git
  configure-aws-profile:
    parameters:
      aws-role-variable-name:
        type: string
        default: AWS_ROLE
      aws-access-key-id-variable-name:
        type: string
        default: AWS_ACCESS_KEY_ID
      aws-secret-access-key-variable-name:
        type: string
        default: AWS_SECRET_ACCESS_KEY
      profile-name:
        type: string
        default: infrastructure
    steps:
      - run:
          name: Configuring AWS profile
          command: |
            mkdir -p ~/.aws

            cat \<<EOF >> ~/.aws/credentials
            [<< parameters.profile-name >>-credentials]
            aws_access_key_id = ${<< parameters.aws-access-key-id-variable-name >>}
            aws_secret_access_key = ${<< parameters.aws-secret-access-key-variable-name >>}

            [<< parameters.profile-name >>]
            source_profile = << parameters.profile-name >>-credentials
            role_arn = ${<< parameters.aws-role-variable-name >>}

            EOF

            echo 'unset << parameters.aws-access-key-id-variable-name >>' >> ${BASH_ENV}
            echo 'unset << parameters.aws-secret-access-key-variable-name >>' >> ${BASH_ENV}
            echo 'export AWS_PROFILE="<< parameters.profile-name >>"' >> ${BASH_ENV}
            echo 'export AWS_SDK_LOAD_CONFIG=1' >> ${BASH_ENV}
  login-ecr:
    parameters:
      aws-region:
        type: string
    steps:
      - run:
          name: Logging in to ECR
          command: |
            if ! which aws > /dev/null; then
              sudo apt-get update --allow-releaseinfo-change && sudo apt-get install -y python3-pip
              sudo pip3 install awscli
            fi

            login="$(aws ecr get-login --no-include-email --region << parameters.aws-region >>)"
            ${login}
  select-or-create-workspace:
    parameters:
      directory:
        type: string
      workspace-name:
        type: string
    steps:
      - run:
          name: Switching to Terraform workspace << parameters.workspace-name >>
          command: |
            function cleanedUpWorkspaces() {
              sed -E 's/^\*? *([^ ]+) *$/\1/'
            }

            workspaceName="<< parameters.workspace-name >>"

            cd << parameters.directory >>
            if [[ -z "$(terraform workspace list | cleanedUpWorkspaces | grep "${workspaceName}")" ]]; then
              echo "Workspace does not currently exist; creating"
              terraform workspace new "${workspaceName}"
            else
              echo "Workspace already exists; selecting"
              terraform workspace select "${workspaceName}"
            fi
  halt-if-not-pr:
    description: Check if current workflow is associated with a pull request, halting job if false
    steps:
      - run:
          name: Ensuring workflow is associated with a pull request
          command: |
            prNumber="${CIRCLE_PR_NUMBER:-${CIRCLE_PULL_REQUEST##*/}}"

            if [[ -z "${prNumber}" ]]; then
              echo "This workflow is not associated with a pull request; halting"
              circleci-agent step halt
            fi
  post-pr-comment:
    parameters:
      comment:
        type: string
      github-access-token:
        type: string
    steps:
      - halt-if-not-pr
      - run:
          name: Posting comment to pull request
          command: |
            prNumber="${CIRCLE_PR_NUMBER:-${CIRCLE_PULL_REQUEST##*/}}"

            statusCode=$(curl -X POST \
              -H 'Accept: application/vnd.github.v3+json' \
              -H "Authorization: token << parameters.github-access-token >>" \
              --output curl.log \
              --write-out "%{http_code}" \
              "https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/issues/${prNumber}/comments" \
              --data @- \<<-EOF
                {
                  "body": "<< parameters.comment >>"
                }
            EOF
            )

            cat curl.log

            if [[ "${statusCode}" -lt "200" ]] || [[ "${statusCode}" -gt "299" ]]; then
              exit 1
            fi
  set-up-npm-authentication:
    parameters:
      npm-authentication-token:
        type: string
    steps:
      - run:
          name: Setting up NPM authentication
          command: |
            echo "//registry.npmjs.org/:_authToken=<< parameters.npm-authentication-token >>" > .npmrc
            npm whoami
  check-docker-image-service-health:
    parameters:
      docker-image:
        type: string
      docker-run-arguments:
        type: string
        default: ""
      health-check-use-https:
        type: boolean
        default: false
      health-check-port:
        type: integer
        default: 80
      health-check-path:
        type: string
    steps:
      - run:
          name: Checking service health from Docker image
          command: |
            echo "Creating container..."

            containerId=$(docker run << parameters.docker-run-arguments >> --detach << parameters.docker-image >>)

            echo "Checking health of container..."
            healthCheckPassed="false"
            protocol="http<<# parameters.health-check-use-https >>s<</ parameters.health-check-use-https >>"
            for index in {1..10}; do
              # We use wget below, as it should be available even on Alpine Linux. Redirecting stderr to stdout
              # helps ensure that the server response is printed before the request body
              if docker exec "${containerId}" wget -q -S -O - "${protocol}://127.0.0.1:<< parameters.health-check-port >><< parameters.health-check-path >>" 2>&1; then
                healthCheckPassed="true"
                break
              fi
              sleep 1 # Wait one second
            done

            statusCode=1
            if [[ "${healthCheckPassed}" == "true" ]]; then
              statusCode=0
            else
              echo "Health check failed. Container logs:"
              docker logs "${containerId}"
            fi

            docker stop "${containerId}" > /dev/null || true
            docker rm "${containerId}" > /dev/null

            exit ${statusCode}
  install-dependencies-npm:
    steps:
      - restore_cache:
          key: node_modules-{{ arch }}-{{ checksum "package-lock.json" }}
      - run:
          name: Installing NPM dependencies
          command: |
            if [[ -e "package-lock.json" ]]; then
              if [[ -d "node_modules" ]]; then
                echo "Cached node_modules found. Skipping install step."
              else
                echo "package-lock.json found, but no cached modules found. Installing with \`npm ci\`..."
                echo ""

                echo "Installing Node.js"
                sudo apt-get update --allow-releaseinfo-change
                curl -sL https://deb.nodesource.com/setup_12.x | sudo bash -
                sudo apt-get install -y nodejs
                echo ""

                npm ci
              fi
            elif [[ -e "package.json" ]]; then
              echo "No package-lock.json found, but package.json found. Installing with \`npm install\`..."
              echo ""

              echo "Installing Node.js"
              sudo apt-get update --allow-releaseinfo-change
              curl -sL https://deb.nodesource.com/setup_12.x | sudo bash -
              sudo apt-get install -y nodejs
              echo ""

              npm install
            fi
      - save_cache:
          key: node_modules-{{ arch }}-{{ checksum "package-lock.json" }}
          paths:
            - node_modules
  install-dependencies-clojure:
    steps:
      - run:
          name: Backing up ~/.m2 directory (if it exists)
          command: |
            if [[ -e ~/.m2 ]]; then
              mv ~/.m2 ~/.m2-temp
            fi
      - restore_cache:
          key: clojure-1.10.1.492-{{ arch }}-{{ checksum "deps.edn" }}
      - run:
          name: Installing Clojure dependencies
          command: |
            if [[ -e "deps.edn" ]]; then
              if [[ -d ~/.m2 ]]; then
                echo "Cached dependencies found. Skipping install step."
              else
                echo "deps.edn found, but no cached dependencies found. Installing dependencies..."
                echo ""

                echo "Installing Clojure"
                sudo apt-get install openjdk-11-jdk
                sudo curl -o /tmp/linux-install-clojure.sh https://download.clojure.org/install/linux-install-1.10.1.492.sh
                sudo chmod +x /tmp/linux-install-clojure.sh
                sudo /tmp/linux-install-clojure.sh
                echo ""

                clojure -Spath # In order to make the classpath, resolve-deps has to be called, which downloads dependencies
              fi
            fi
      - save_cache:
          key: clojure-1.10.1.492-{{ arch }}-{{ checksum "deps.edn" }}
          paths:
            - .cpcache
            - ~/.m2
      - run:
          name: Merging backed up ~/.m2 directory into new ~/.m2 directory (if they exist)
          command: |
            if [[ -e ~/.m2-temp && ! -e ~/m2 ]]; then
              mv ~/.m2-temp ~/.m2
            fi

            if [[ -e ~/.m2-temp && -e ~/.m2 ]]; then
              echo "Installing merge-directories"
              wget https://github.com/edahlseng/merge-directories/releases/download/v0.1.0/merge-directories_v0.1.0_linux_amd64.zip
              unzip merge-directories_v0.1.0_linux_amd64.zip
              rm merge-directories_v0.1.0_linux_amd64.zip
              ./merge-directories_v0.1.0_linux_amd64 --mv ~/.m2-temp ~/.m2
              rm ./merge-directories_v0.1.0_linux_amd64
            fi
  install-required-terraform-version:
    parameters:
      directory:
        type: string
    steps:
      - run:
          name: Installing required Terraform version
          command: |
            cd << parameters.directory >>

            [[ -f versions.tf ]] && filename="versions.tf" || filename="main.tf"
            desiredTerraformVersion=$(cat ${filename} | grep --extended-regexp '^\s*required_version\s*=\s*"\s*(=|>=)?\s*[0-9]+\.[0-9]+\.[0-9]+\s*"\s*$' | head | sed -E 's/^.*([0-9]+\.[0-9]+\.[0-9]+).*$/\1/')
            tfenv install "${desiredTerraformVersion}" && tfenv use "${desiredTerraformVersion}"
  install-terraform-version:
    parameters:
      version:
        type: string
    steps:
      - run:
          name: Installing Terraform Version << parameters.version >>
          command: tfenv install << parameters.version >>
  create-terraform-plan:
    parameters:
      directory:
        type: string
      lock-timeout:
        type: string
    steps:
      - run:
          name: Creating Terraform Plan
          command: cd << parameters.directory >> && terraform plan -input=false -lock-timeout=<< parameters.lock-timeout >> -out=terraform.plan | tee terraform-output.log
  apply-terraform-plan:
    parameters:
      directory:
        type: string
      ignore-missing-plan:
        type: boolean
      lock-timeout:
        type: string
    steps:
      - run:
          name: Applying Terraform Plan
          command: |
            cd << parameters.directory >>

            <<# parameters.ignore-missing-plan >>
              if [[ -e "terraform.plan" ]]; then
                terraform apply -input=false -lock-timeout=<< parameters.lock-timeout >> "terraform.plan" | tee terraform-output.log
              else
                terraform apply -input=false -lock-timeout=<< parameters.lock-timeout >> -auto-approve | tee terraform-output.log
              fi
              exit
            <</ parameters.ignore-missing-plan >>

            terraform apply -input=false -lock-timeout=<< parameters.lock-timeout >> "terraform.plan" | tee terraform-output.log
  run-pre-init-script:
    description: Runs a pre-init.sh script, primarily used for setting up third-party Terraform providers
    parameters:
      directory:
        type: string
    steps:
      - run:
          name: Running pre-init script
          command: |
            if [[ -e << parameters.directory >>/pre-init.sh ]]; then
              << parameters.directory >>/pre-init.sh
            fi
  set-up-environment-variables-from-suffix:
    description: Sets up environment variables from source variables that have a specified suffix
    parameters:
      suffix:
        type: string
    steps:
      - run:
          name: Setting up environment variables
          command: |
            for variable in $(compgen -e | grep -E "<< parameters.suffix >>$"); do
              echo "Creating ${variable%<< parameters.suffix >>} variable, from ${variable}"
              echo "export ${variable%<< parameters.suffix >>}=\"${!variable}\"" >> ${BASH_ENV}
            done
  set-up-terraform-variables:
    description: Saves Terraform variables to a terraform.tfvars file. This command does not do much other than allow for easier to understand syntax in a .circleci/config.yml file.
    parameters:
      directory:
        type: string
      variables:
        type: string
    steps:
      - run:
          name: Setting up Terraform variables
          command: echo "<< parameters.variables >>" | tee -a << parameters.directory >>/terraform.tfvars
  log-in-to-docker-hub:
    description: Logs the current Docker daemon into Docker Hub
    parameters:
      username:
        type: string
      password:
        type: string
    steps:
      - run:
          name: Logging in to Docker Hub
          command: echo "<< parameters.password >>" | docker login -u "<< parameters.username >>" --password-stdin
  halt:
    description: Halts the job if the specified condition is true
    parameters:
      if:
        type: string
    steps:
      - run:
          name: Ensuring job should continue
          command: |
            if << parameters.if >>; then
              echo "Condition not met, halting"
              circleci-agent step halt
            fi
  tag-current-commit:
    description: Creates a Git tag for the current commit, and pushes that tag to the Git remote
    parameters:
      tag:
        type: string
    steps:
      - run:
          name: Creating Git tag
          command: git tag "<< parameters.tag >>"
      - put-directory:
          path: .git
      - run:
          name: Pushing tag to Git remote
          command: git push --tags
  get-eks-token:
    description: Generates EKS authentication token, adding it to the list of exported variables for subsequent commands
    parameters:
      cluster-name:
        type: string
        default: eks-cluster
      environment-variable-name:
        type: string
        default: KUBE_TOKEN
      region:
        type: string
        default: us-east-1
    steps:
      - run:
          name: Getting authentication token
          command: |
            if ! which aws > /dev/null; then
              sudo apt-get update --allow-releaseinfo-change && sudo apt-get install -y python3-pip
              sudo pip3 install awscli
            fi

            eksAuthToken=$(aws eks get-token --region << parameters.region >> --cluster-name << parameters.cluster-name >> | jq -r .status.token)
            echo "export << parameters.environment-variable-name >>="${eksAuthToken}"" >> ${BASH_ENV}

jobs:
  build:
    parameters:
      executor:
        type: executor
        default: buildpack-deps
      variant:
        type: string
        description: The variant to build
        default: ""
    executor: << parameters.executor >>
    steps:
      - get-workspace
      - run:
          name: Building
          command: |
            if which make > /dev/null && [[ -e Makefile ]]; then
              make build<<# parameters.variant >>-<</ parameters.variant >><< parameters.variant >>
              exit 0
            fi

            if which npm > /dev/null && [[ -e package.json ]]; then
              npm run build<<# parameters.variant >>-<</ parameters.variant >><< parameters.variant >>
              exit 0
            fi

            echo "Unable to find a command runner"
            exit 1
      - put-directory:
          path: .
  checkout:
    parameters:
      setup-steps:
        type: steps
        default: []
      executor:
        type: executor
        default: buildpack-deps
    executor: << parameters.executor >>
    steps:
      - checkout
      - steps: << parameters.setup-steps >>
      - put-all
  install-dependencies:
    parameters:
      setup-steps:
        type: steps
        default: []
    executor: buildpack-deps
    steps:
      - checkout
      - steps: << parameters.setup-steps >>
      - install-dependencies-clojure
      - install-dependencies-npm
      - put-all
      - run:
          name: Ensuring that remaining workspace directories outside of the project directory have been created
          command: mkdir -p ~/.m2
      - put-path:
          relative-to: "~"
          path: .m2
  install-dependencies-npm: # Deprecated (use install-dependencies, instead)
    parameters:
      setup-steps:
        type: steps
        default: []
    executor: node
    steps:
      - checkout
      - steps: << parameters.setup-steps >>
      - install-dependencies-npm
      - put-all
  lint:
    parameters:
      executor:
        type: executor
        default: buildpack-deps
      language:
        type: string
        description: The language to lint
        default: ""
    executor: << parameters.executor >>
    steps:
      - get-workspace
      - run:
          name: Linting << parameters.language >>
          command: |
            if which make > /dev/null && [[ -e Makefile ]]; then
              make lint<<# parameters.language >>-<</ parameters.language >><< parameters.language >>
              exit 0
            fi

            if which npm > /dev/null && [[ -e package.json ]]; then
              npm run lint<<# parameters.language >>-<</ parameters.language >><< parameters.language >>
              exit 0
            fi

            echo "Unable to find a command runner"
            exit 1
      - put-test-results:
          path: ./linting-results
  validate-circleci-orb:
    executor: circleci-cli/default
    steps:
      - get-workspace
      - orbs/validate:
          orb-path: sources/index.yml
  lint-circleci-orb: # Deprecated (use validate-circleci-orb, instead)
    executor: circleci-cli/default
    steps:
      - get-workspace
      - orbs/validate:
          orb-path: sources/index.yml
  lint-commit: # Deprecated (use lint, instead)
    executor: node
    steps:
      - get-workspace
      - run:
          name: Linting commit messages
          command: npm run lint-report:commit -- --from origin/master
      - put-test-results:
          path: ./linting-results
  lint-css: # Deprecated (use lint, instead)
    executor: node
    steps:
      - get-workspace
      - run:
          name: Linting CSS
          command: npm run lint-report:css
      - put-test-results:
          path: ./linting-results
  lint-js: # Deprecated (use lint, instead)
    executor: node
    steps:
      - get-workspace
      - run:
          name: Linting JavaScript files
          command: npm run lint-report:js
      - put-test-results:
          path: ./linting-results
  lint-json: # Deprecated (use lint, instead)
    executor: node
    steps:
      - get-workspace
      - run:
          name: Linting JSON files
          command: npm run lint-report:json
      - put-test-results:
          path: ./linting-results
  lint-terraform: # Deprecated (use lint, instead)
    parameters:
      directory:
        type: string
        default: "."
      recursive:
        type: boolean
        default: true
      terraform-image-tag:
        type: string
    executor: tfenv
    steps:
      - get-workspace
      - run:
          name: Linting Terraform files
          command: |
            cd << parameters.directory >>

            recursive_arg=""
            if << parameters.recursive >>; then
               recursive_arg="-recursive"
            fi

            tfenv install << parameters.terraform-image-tag >>
            terraform fmt -check=true $recursive_arg
  lint-yaml: # Deprecated (use lint, instead)
    executor: node
    steps:
      - get-workspace
      - run:
          name: Linting YAML files
          command: npm run lint-report:yaml
      - put-test-results:
          path: ./linting-results
  test:
    parameters:
      executor:
        type: executor
        default: buildpack-deps
      variant:
        type: string
        description: The variant to test
        default: ""
      setup-steps:
        type: steps
        default: []
      error-if-missing:
        type: boolean
        default: true
      make-target:
        type: string
        default: "test"
    executor: << parameters.executor >>
    steps:
      - get-workspace
      - steps: << parameters.setup-steps >>
      - run:
          name: Running tests
          command: |
            if which make > /dev/null && [[ -e Makefile ]] && make -n <<parameters.make-target>>; then
              make <<parameters.make-target>>
            else
              if <<parameters.error-if-missing>>; then
                echo "Unable to find a command runner"
                exit 1
              else
                echo "No makefile with <<parameters.make-target>> target found. Assuming there's no tests to run"
                exit 0
              fi
            fi
      - put-test-results:
          path: ./test-results
      - store_artifacts:
          path: ./coverage
          destination: coverage
  create-github-release:
    executor: buildpack-deps
    parameters:
      github-access-token:
        type: string
      artifact-paths:
        type: string
        default: ""
    steps:
      - get-workspace
      - halt-if-not-release-commit
      - run:
          name: Creating release
          command: |
            versionTag=$(git log --format=%b -n 1 ${CIRCLE_SHA1} | sed -r 's/New Release: //')

            # Pull details from changelog

            startCollectingRegExp='^#+ \[?'"${versionTag:1}"'\]?.*$'
            stopCollectingRegExp='^<a name="[0-9]+\.[0-9]+\.[0-9]+">.*$|^#+ \[?[0-9]+\.[0-9]+\.[0-9]+.*$'

            collectingLines="false"
            content=""
            while IFS="" read -r line || [ -n "${line}" ]
            do
              if [[ "${collectingLines}" == "true" ]]; then
                if [[ "${line}" =~ ${stopCollectingRegExp} ]]; then
                  break
                fi
                content="${content}"$'\n'"${line}"
              elif [[ "${line}" =~ ${startCollectingRegExp} ]]; then
                collectingLines="true"
              fi
            done < CHANGELOG.md

            [[ "${content}" =~ ^[[:space:]]*([^[:space:]].*[^[:space:]])[[:space:]]*$ ]]
            releaseDetails="${BASH_REMATCH[1]}"

            # Create release

            releaseDetailsForJson=${releaseDetails//$'\n'/"\n"} # We need to escape the newline control character. (See section 2.5: https://www.ietf.org/rfc/rfc4627.txt)
            releaseDetailsForJson=${releaseDetailsForJson//'"'/'\"'} # Escape double quotes

            curl -X POST \
              -H 'Accept: application/vnd.github.v3+json' \
              -H "Authorization: token << parameters.github-access-token >>" \
              "https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/releases" \
              --data @- \<<-EOF | tee curl.log
                {
                  "tag_name": "${versionTag}",
                  "name": "Version ${versionTag:1}",
                  "body": "${releaseDetailsForJson}"
                }
            EOF

            idFromResponse=$(cat curl.log | jq -r .id || echo "null")

            if [[ "${idFromResponse}" == "null" ]]; then
              echo "Unsuccessful request to create GitHub release"
              exit 1
            fi

            <<# parameters.artifact-paths >>
              artifactPaths=(<< parameters.artifact-paths>>)
              artifactUploadUrl=$(cat curl.log | jq -r .upload_url | sed -r 's/^(.*)\{\?name,label\}$/\1/')

              echo "Uploading ${#artifactPaths} artifacts: ${artifactPaths[@]}"

              for artifactPath in "${artifactPaths[@]}"; do
                curl -X POST \
                  -H "Authorization: token << parameters.github-access-token >>" \
                  -H "Content-Type: $(file -b --mime-type "${artifactPath}")" \
                  "${artifactUploadUrl}?name=$(basename "${artifactPath}")" \
                  --data-binary "@${artifactPath}"
              done
            <</ parameters.artifact-paths >>
  create-release-pr:
    executor: node
    parameters:
      git-ssh-fingerprint:
        type: string
      git-user-email:
        type: string
      git-user-name:
        type: string
      github-access-token:
        type: string
    steps:
      - get-workspace
      - halt-if-release-commit
      - setup-git-user:
          git-ssh-fingerprint: << parameters.git-ssh-fingerprint >>
          git-user-email: << parameters.git-user-email >>
          git-user-name: << parameters.git-user-name >>
      - run:
          name: Creating release branch
          command: |
            git checkout -b ci/release
            git reset --hard origin/master
      - run:
          name: Creating release
          command: npm run release
      - run:
          name: Force-pushing branch
          command: git push origin ci/release --force
      - run:
          name: Creating or updating pull request
          command: |
            versionTag=$(git log --format=%B -n 1 HEAD | head -n 1 | sed -r 's/chore\(release\): ([0-9]+\.[0-9]+\.[0-9]+)/v\1/')
            echo "Version tag is: ${versionTag}"

            # ------------------------------------------------------------------
            # Examine CHANGELOG to see if if there were any release-worthy changes
            # ------------------------------------------------------------------

            startCollectingRegExp='^#+ \[?'"${versionTag:1}"'\]?.*$'
            stopCollectingRegExp='^<a name="[0-9]+\.[0-9]+\.[0-9]+">.*$|^#+ \[?[0-9]+\.[0-9]+\.[0-9]+.*$'

            collectingLines="false"
            content=""
            while IFS="" read -r line || [ -n "${line}" ]
            do
              if [[ "${collectingLines}" == "true" ]]; then
                if [[ "${line}" =~ ${stopCollectingRegExp} ]]; then
                  break
                fi
                content="${content}"$'\n'"${line}"
              elif [[ "${line}" =~ ${startCollectingRegExp} ]]; then
                collectingLines="true"
              fi
            done < CHANGELOG.md

            if ! [[ "${content}" =~ ^[[:space:]]*([^[:space:]].*[^[:space:]])[[:space:]]*$ ]]; then
              # The Changelog is empty, so let's not create a PR. In the worst case,
              # we'll over-eagerly avoid automatically creating a PR, but the branch
              # will still have been pushed, so the user can easily create a PR
              # if need be.

              echo "Changelog appears to be empty. Exiting..."
              exit 0
            fi

            # ------------------------------------------------------------------
            # Create Pull Request
            # ------------------------------------------------------------------

            echo "Creating pull request..."

            curl -w "%{http_code}\n" -X POST \
              -H 'Accept: application/vnd.github.v3+json' \
              -H "Authorization: token << parameters.github-access-token >>" \
              https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/pulls \
              --data @- \<<-EOF | tee curl.log
                {
                  "title": "New Release: ${versionTag}",
                  "head": "ci/release",
                  "base": "master",
                  "body": "This pull request creates a new release. It will be updated whenever a new commit is pushed to master."
                }
            EOF

            releasePullRequestNumber=$(curl -X GET -H 'Accept: application/vnd.github.v3+json' -H "Authorization: token << parameters.github-access-token >>" "https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/pulls?base=master&head=${CIRCLE_PROJECT_USERNAME}:ci%2Frelease" | { grep -E '^\s*"number":\s*[0-9]+,?\s*$' || true; } | sed -E 's/.*[^[0-9]([0-9]+)[^0-9].*/\1/')

            if [[ $(cat curl.log | tail -n 1) == 422 && -n "${releasePullRequestNumber}" ]]; then
              echo "Pull request already exists. Updating title to use the new version..."

              curl -X PATCH \
                -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token << parameters.github-access-token >>" \
                https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/pulls/${releasePullRequestNumber} \
                --data @- \<<-EOF
                  {
                    "title": "New Release: ${versionTag}"
                  }
            EOF
            fi
  publish-circleci-dev:
    executor: circleci-cli/default
    parameters:
      orb-ref:
        description: A versionless orb-ref in the form <namespace>/<orb-name>
        type: string
      token-variable:
        description: Name of env var containing your token. Pass this as a raw string such as ORB_PUBLISHING_TOKEN. Do not paste the actual token into your configuration.
        type: string
    steps:
      - get-workspace
      - orbs/publish:
          orb-path: sources/index.yml
          orb-ref: << parameters.orb-ref >>@dev:$(echo "${CIRCLE_BRANCH//[^a-zA-Z0-9-]/-}" | tr '[:upper:]' '[:lower:]')
          token-variable: << parameters.token-variable >>
  tag:
    executor: buildpack-deps
    parameters:
      git-ssh-fingerprint:
        type: string
      git-user-email:
        type: string
      git-user-name:
        type: string
    steps:
      - get-workspace
      - halt-if-not-release-commit
      - setup-git-user:
          git-ssh-fingerprint: << parameters.git-ssh-fingerprint >>
          git-user-email: << parameters.git-user-email >>
          git-user-name: << parameters.git-user-name >>
      - tag
  tag-and-publish-circleci:
    executor: circleci-cli/default
    parameters:
      git-ssh-fingerprint:
        type: string
      git-user-email:
        type: string
      git-user-name:
        type: string
      orb-ref:
        description: A versionless orb-ref in the form <namespace>/<orb-name>
        type: string
      token-variable:
        description: Name of env var containing your token. Pass this as a raw string such as ORB_PUBLISHING_TOKEN. Do not paste the actual token into your configuration.
        type: string
    steps:
      - get-workspace
      - halt-if-not-release-commit
      - setup-git-user:
          git-ssh-fingerprint: << parameters.git-ssh-fingerprint >>
          git-user-email: << parameters.git-user-email >>
          git-user-name: << parameters.git-user-name >>
      - tag
      - orbs/publish:
          orb-path: sources/index.yml
          orb-ref: >-
            << parameters.orb-ref >>@$(git log --format=%b -n 1 ${CIRCLE_SHA1} | sed -r 's/New Release: v//')
          token-variable: << parameters.token-variable >>
  tag-and-publish-npm:
    executor: node
    parameters:
      git-ssh-fingerprint:
        type: string
      git-user-email:
        type: string
      git-user-name:
        type: string
      npm-authentication-token:
        type: string
    steps:
      - get-workspace
      - halt-if-not-release-commit
      - setup-git-user:
          git-ssh-fingerprint: << parameters.git-ssh-fingerprint >>
          git-user-email: << parameters.git-user-email >>
          git-user-name: << parameters.git-user-name >>
      - tag
      - set-up-npm-authentication:
          npm-authentication-token: << parameters.npm-authentication-token >>
      - run:
          name: Publishing to NPM
          command: npm publish
  terraform-plan:
    parameters:
      directory:
        type: string
      terraform-image-tag: # Unused and deprecated, but included to provide backwards compatibility
        type: string
        default: ""
      setup-steps:
        type: steps
        default: []
      workspace:
        type: string
        default: default
      lock-timeout:
        type: string
        default: "0s"
    executor:
      name: tfenv
    steps:
      - get-workspace
      - install-required-terraform-version:
          directory: << parameters.directory >>
      - steps: << parameters.setup-steps >>
      - run:
          name: Initializing Terraform
          command: cd << parameters.directory >> && terraform init -input=false
      - select-or-create-workspace:
          directory: << parameters.directory >>
          workspace-name: << parameters.workspace >>
      - create-terraform-plan:
          directory: << parameters.directory >>
          lock-timeout: << parameters.lock-timeout >>
      - put-path:
          path: << parameters.directory >>/terraform.plan
  terraform-run:
    parameters:
      lock-timeout:
        type: string
        default: "0s"
      directory:
        type: string
      post-plan-steps:
        description: A list of steps to run after the plan. These steps will always run, even if the Terraform apply will not run (in which case post-steps will also not run).
        type: steps
        default: []
      setup-steps:
        type: steps
        default: []
      should-apply:
        type: string
        default: "true"
      workspace:
        type: string
        default: default
    executor:
      name: tfenv
    steps:
      - get-workspace
      - install-required-terraform-version:
          directory: << parameters.directory >>
      - steps: << parameters.setup-steps >>
      - run:
          name: Initializing Terraform
          command: cd << parameters.directory >> && terraform init -input=false
      - select-or-create-workspace:
          directory: << parameters.directory >>
          workspace-name: << parameters.workspace >>
      - create-terraform-plan:
          directory: << parameters.directory >>
          lock-timeout: << parameters.lock-timeout >>
      - run:
          name: Checking if apply should run
          command: |
            if ! << parameters.should-apply >>; then
              circleci-agent step halt
            fi
      - apply-terraform-plan:
          directory: << parameters.directory >>
          ignore-missing-plan: false
          lock-timeout: << parameters.lock-timeout >>
  terraform-apply:
    parameters:
      directory:
        type: string
      terraform-image-tag: # Unused and deprecated, but included to provide backwards compatibility
        type: string
        default: ""
      setup-steps:
        type: steps
        default: []
      ignore-missing-plan:
        type: boolean
        default: false
      workspace:
        type: string
        default: default
      lock-timeout:
        type: string
        default: "0s"
    executor:
      name: tfenv
    steps:
      - get-workspace
      - install-required-terraform-version:
          directory: << parameters.directory >>
      - steps: << parameters.setup-steps >>
      - run:
          name: Initializing Terraform
          command: cd << parameters.directory >> && terraform init -input=false
      - select-or-create-workspace:
          directory: << parameters.directory >>
          workspace-name: << parameters.workspace >>
      - apply-terraform-plan:
          directory: << parameters.directory >>
          ignore-missing-plan: << parameters.ignore-missing-plan >>
          lock-timeout: << parameters.lock-timeout >>
  validate-js:
    parameters:
      setup-steps:
        type: steps
        default: []
    executor: node
    steps:
      - get-workspace
      - steps: << parameters.setup-steps >>
      - run:
          name: Validating JavaScript files
          command: npm run validate:js
  validate-terraform:
    parameters:
      directories:
        type: string
      terraform-image-tag: # Unused and deprecated, but included to provide backwards compatibility
        type: string
        default: ""
      setup-steps:
        type: steps
        default: []
      run-validate-after-init: # Needed in order to get a minimal amount of validation for modules (which are very hard to run terraform validate on without extra configuration)
        type: boolean
        default: true
    executor:
      name: tfenv
    steps:
      - get-workspace
      - steps: << parameters.setup-steps >>
      - run:
          name: Validiting Terraform configuration
          command: |
            directories=(<< parameters.directories >>)

            for directory in "${directories[@]}"; do
              cd ${directory}

              [[ -f versions.tf ]] && filename="versions.tf" || filename="main.tf"
              desiredTerraformVersion=$(cat ${filename} | grep --extended-regexp '^\s*required_version\s*=\s*"\s*(=|>=)?\s*[0-9]+\.[0-9]+\.[0-9]+\s*"\s*$' | head | sed -E 's/^.*([0-9]+\.[0-9]+\.[0-9]+).*$/\1/')
              tfenv install "${desiredTerraformVersion}" && tfenv use "${desiredTerraformVersion}"

              terraform init -input=false
              <<# parameters.run-validate-after-init >>
                terraform validate
              <</ parameters.run-validate-after-init >>
              cd -
            done
  build-image:
    parameters:
      setup-steps:
        type: steps
        default: []
      dockerfile-path:
        type: string
      path:
        type: string
      tag:
        type: string
      build-options:
        type: string
        default: ""
      docker_layer_caching:
        type: boolean
        default: false
    executor: buildpack-deps
    steps:
      - get-workspace
      - setup_remote_docker:
          docker_layer_caching: << parameters.docker_layer_caching >>
      - steps: << parameters.setup-steps >>
      - run:
          name: Building Docker image
          command: docker build --file << parameters.dockerfile-path >> --tag << parameters.tag >> << parameters.build-options >> << parameters.path >>
      - run:
          name: Pushing Docker image
          command: docker push << parameters.tag >>
  cleanup-isolated-commit-deployments:
    parameters:
      directory:
        type: string
      terraform-image-tag: # Unused and deprecated, but included to provide backwards compatibility
        type: string
        default: ""
      github-access-token:
        type: string
      setup-steps:
        type: steps
        default: []
      maximumCommitCount:
        type: integer
      lock-timeout:
        type: string
        default: "0s"
    executor:
      name: tfenv
    steps:
      - get-workspace
      - steps: << parameters.setup-steps >>
      - install-required-terraform-version:
          directory: << parameters.directory >>
      - run:
          name: Finding and destroying outdated PR deployments
          command: |
            function cleanedUpWorkspaces() {
              sed -E 's/^\*? *([^ ]+) *$/\1/'
            }

            function onlyCommitWorkspaces() {
              # For more context on the error handling, see: https://stackoverflow.com/questions/6550484/prevent-grep-returning-an-error-when-input-doesnt-match/49627999#49627999
              grep -E '^git-[0-9a-fA-F]+$' || test $? = 1
            }

            function commitWorkspaces() {
              cleanedUpWorkspaces | onlyCommitWorkspaces
            }

            function withoutOutdatedCommits() {
              read -d '' workspaces
              for workspace in ${workspaces[@]}; do
                commit=$(echo "${workspace}" | sed -E 's/^git-(.+)$/\1/')
                if [[ "$(git rev-list --count HEAD ^"${commit}")" -gt << parameters.maximumCommitCount >> ]]; then
                  echo ${workspace}
                fi
              done
            }

            cd << parameters.directory >>
            terraform init -input=false

            allWorkspaces="$(terraform workspace list)"
            echo "The following Terraform workspaces exist:"
            echo "${allWorkspaces[@]}"
            echo ""

            workspacesToDestroy="$(echo "${allWorkspaces[@]}" | commitWorkspaces | withoutOutdatedCommits)"
            echo "The following workspaces are eligible for destruction:"
            echo "${workspacesToDestroy[@]}"
            echo ""

            for workspace in ${workspacesToDestroy[@]}; do
              terraform workspace select "${workspace}"
              terraform destroy -lock-timeout=<< parameters.lock-timeout >> -auto-approve
              terraform workspace select default
              terraform workspace delete "${workspace}"
            done

            echo "The following Terraform workspaces still exist:"
            terraform workspace list
  cleanup-pr-deployments:
    parameters:
      directory:
        type: string
      terraform-image-tag: # Unused and deprecated, but included to provide backwards compatibility
        type: string
        default: ""
      github-access-token:
        type: string
      setup-steps:
        type: steps
        default: []
      lock-timeout:
        type: string
        default: "0s"
    executor:
      name: tfenv
    steps:
      - get-workspace
      - steps: << parameters.setup-steps >>
      - install-required-terraform-version:
          directory: << parameters.directory >>
      - run:
          name: Finding and destroying outdated PR deployments
          command: |
            function openPrWorkspaces() {
              curl -X GET \
                -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token << parameters.github-access-token >>" \
                "https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/pulls" | jq -r '.[] | "pr-\(.number)"'
            }

            function cleanedUpWorkspaces() {
              sed -E 's/^\*? *([^ ]+) *$/\1/'
            }

            function onlyPrWorkspaces() {
              # For more context on the error handling, see: https://stackoverflow.com/questions/6550484/prevent-grep-returning-an-error-when-input-doesnt-match/49627999#49627999
              grep -E '^pr-[0-9]+$' || test $? = 1
            }

            function prWorkspaces() {
              terraform workspace list | cleanedUpWorkspaces | onlyPrWorkspaces
            }

            function withoutOpenPrs() {
              read -d '' workspaces
              for openPrWorkspace in $(openPrWorkspaces); do
                workspaces=$(echo "${workspaces[@]}" | grep -v "${openPrWorkspace}")
              done
              echo "${workspaces[@]}"
            }

            cd << parameters.directory >>
            terraform init -input=false
            for workspace in $(prWorkspaces | withoutOpenPrs); do
              terraform workspace select "${workspace}"
              terraform destroy -lock-timeout=<< parameters.lock-timeout >> -auto-approve
              terraform workspace select default
              terraform workspace delete "${workspace}"
            done
